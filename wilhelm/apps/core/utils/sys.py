'''
Utilites for dealing with the file-system or operating system.
'''

from __future__ import absolute_import

#=============================================================================
# Standard library imports.
#=============================================================================
import errno
import hashlib
import os
import pip
import platform
import sys

#================================ End Imports ================================

stderr = sys.stderr
stdout = sys.stdout

def mkdir_p(path):
    '''
    Make a directory, making parents if necessary.
    Taken verbatim from
    http://stackoverflow.com/a/600612
    '''
    try:
        os.makedirs(path)
    except OSError as exc: # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else: raise

def checksum(argument, algorithm='sha256'):
    '''
    Returns the hash checksum of `argument'.
    If `argument' is a name of a file, then perform the checksum on the file.
    Otherwise, the checksum is of the string `argument'.
    By default, it will be the sha1 checksum (and so equivalent to linux's
    sha1sum). Alternatively, the algorithm could be md5 (equivalent to linux's
    md5sum), or else sha224, sha256, sha384, sha512.
    '''

    h = hashlib.new(algorithm)

    if os.path.exists(argument) and os.path.isfile(argument):
        argument = open(argument,'rb').read()

    h.update(argument)

    return h.hexdigest()

def list_directory_checksums(rootdir, algorithm='sha256'):
    '''
    Descend through a directory, rooted at rootdir. Return a list of the full
    and relative paths of all files in the directory along with their
    checksums.
    '''
    file_list = []
    rootdir = os.path.abspath(rootdir)
    for _dir, subdirs, files in os.walk(rootdir):
        files = [f for f in files if not f[0] == '.']
        subdirs[:] = [d for d in subdirs if not d[0] == '.']
        if files:
            for _file in files:
                file_path = os.path.join(_dir, _file)
                # Get relative path by removing the rootdir.
                file_full_path = os.path.abspath(file_path)
                if rootdir[-1] != os.path.sep:
                    _rootdir = rootdir + os.path.sep
                else:
                    _rootdir = rootdir
                file_relative_path = file_full_path.replace(_rootdir, '', 1)
                file_list.append(
                    (file_full_path,
                    file_relative_path, 
                    checksum(file_path, algorithm)
                    )
                )
    return file_list


def check_directory_checksums(checksum_list, rootdir):
    '''
    Given a checksum list (as generated by, for example,
    list_directory_checksums) and the root of a directory, check if the hashes
    of files in the directory match those listed in the checksum list.
    '''
    for full_file_path, relative_file_path, _hash in checksum_list:
        file_path = os.path.join(rootdir, relative_file_path)
        assert checksum(file_path) == _hash

    return True # If we get this far, all is good.

def file_exists(file_path):
    ''' Simply, assert that file_path is a file that exists?'''
    return os.path.exists(file_path) and os.path.isfile(file_path)

def assert_file_exists(file_path):
    ''' Simply, assert that file_path is a file that exists?'''
    assert file_exists(file_path), 'The file %s does not exist' % file_path

def thisDir(filename):

    '''
    Return the path of the named file.
    '''

    return os.path.abspath(os.path.dirname(filename))


def get_python_info():

    """
    Return list of tuples with Python implemention and version information.

    """

    build_number, build_date = platform.python_build()

    return [('Python implementation', platform.python_implementation()),
            ('Python version', platform.python_version()),
            ('Python build number', build_number),
            ('Python build date', build_date),
            ('Python build compiler', platform.python_compiler())]


def get_platform_info():

    """
    Return list of tuples with operating sytem and platform information.

    """

    (operating_system, 
     compute_node, 
     os_release, 
     os_release_version,
     machine_type, 
     processor) = platform.uname()

    return zip(('Operating system',
                'OS release',
                'OS release version',
                'Machine type',
                'Compute node name'),
               (operating_system,
                os_release,
                os_release_version,
                machine_type,
                compute_node))


def get_pip_installed_packages(as_pip_freeze=False):

    """
    Return a list of pip installed packages and their version numbers.
    
    A list of (name, version_number) packages will be returned.

    """

    return [
        (package.key, package.version) 
         for package in pip.get_installed_distributions()
    ]


def get_pip_requirements():

    """
    A list of strings in the form of 'package_name==package_number'.
    These can be used to make a requirements.txt file to be used as e.g. "pip
    install -r requirments.txt".

    """

    return sorted(['%s==%s' % installed_package 
                   for installed_package in get_pip_installed_packages()])
